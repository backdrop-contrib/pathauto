<?php
/* $Id$ */

// Look for any extensions installed in the pathauto directory
$path = drupal_get_path('module', 'pathauto');
$files = file_scan_directory($path, '^pathauto_.*\.inc$');
foreach ($files as $filename => $file) {
  include_once($filename);
}

function pathauto_help($section = 'admin/modules#description') {
  switch ($section) {
    case 'admin/modules#description':
      $output = t('Provides a mechanism for modules to automatically '.
        'generate aliases for the content they manage.');
      break;
    case 'admin/help#pathauto':
      $output = t('Provides a mechanism for modules to automatically '.
        'generate aliases for the content they manage.');
      break;
  }

  return $output;
}

function pathauto_perm() {
  return array('administer pathauto'); 
}

function pathauto_settings() {
  // Restrict administration of this module
  if (!user_access('administer pathauto')) {
    return message_access();
  }
  
  $output = '';

  // Insist that path.module be enabled
  if (!module_exist('path')) {
    $output .= t('<p>The pathauto module is an extension of the <b>path</b> '.
      'module - you must <a href-"admin/modules">enable <b>path</b></a> to use it.</p>');
    return $output;
  }
  
  // Check for any updates
  _pathauto_update();
  
  // Generate the form - settings applying to all patterns first
  $items = '';
  $items .= form_checkbox(t('Verbose'), 'pathauto_verbose', 1,
    variable_get('pathauto_verbose', FALSE), 
    t('Display alias changes (except during bulk updates).'));
  
  $items .= form_textfield(t('Separator'), 'pathauto_separator',  
    variable_get('pathauto_separator', '_'), 1, 1,
    t('Character used to separate words in titles. This will replace '.
      'any spaces and punctuation characters.'), 
    '', FALSE);

  $items .= form_checkbox(t('Create feed aliases'), 'pathauto_applytofeed', 1,
    variable_get('pathauto_applytofeed', FALSE), t('Also generate aliases for RSS feeds.'));
  
  $items .= form_checkbox(t('Create index aliases'), 'pathauto_indexaliases', 1,
    variable_get('pathauto_indexaliases', FALSE),
    t('When a pattern generates a hierarchical alias (i.e., any alias '.
      'containing a slash), generate aliases for each step of the '.
      'hierarchy which can be used to list content within that hierarchy. '.
      'For example, if a node alias "music/concert/beethoven" is created, '.
      'also create an alias "music/concert" which will list all concert nodes, '.
      'and an alias "music" which will list all music nodes.'));
  // If requested, do a bulk generation of index aliases
  $do_index_bulkupdate = variable_get('pathauto_indexaliases_bulkupdate', FALSE);
  variable_set('pathauto_indexaliases_bulkupdate', FALSE);
  $items .= form_checkbox(t('Bulk generate index aliases'), 
    'pathauto_indexaliases_bulkupdate', 1, FALSE, 
    t('Generate index aliases based on all pre-existing aliases.'));

  $items .= form_radios(t('Update action'), 'pathauto_update_action',
    variable_get('pathauto_update_action', 0), 
    array(t('Do nothing, leaving the old alias intact'), 
          t('Create a new alias in addition to the old alias'), 
          t('Create a new alias, replacing the old one')), 
    t('When updating an existing content item which already has an alias, '.
      'what should pathauto do?'));

  $output .= form_group(t('General settings'), $items, t(''));
  
  // Call the hook on all modules - an array of 'settings' objects is returned
  $all_settings = module_invoke_all('pathauto', 'settings');
  $modulelist = '';
  foreach ($all_settings as $settings) {
    $items = '';
    $module = $settings->module;
    $modulelist[] = $module;
    $patterndescr = $settings->patterndescr;
    $patterndefault = $settings->patterndefault;
    $groupheader = $settings->groupheader;
    $supportsfeeds = $settings->supportsfeeds;
    variable_set('pathauto_'.$module.'_supportsfeeds', $supportsfeeds);
    
    // Prompt for the default pattern for this module
    $variable = 'pathauto_'.$module.'_pattern';
    $items .= form_textfield($patterndescr,
                             $variable,
                             variable_get($variable,$patterndefault),
                             65,
                             128,
                             NULL,
                             NULL,
                             FALSE);

    // If the module supports a set of specialized patterns, set
    // them up here
    if ($settings->patternitems) {
      foreach ($settings->patternitems as $itemname => $itemlabel) {
        $variable = 'pathauto_'.$module.'_'.$itemname.'_pattern';
        $items .= form_textfield($itemlabel,
                                 $variable,
                                 variable_get($variable,''),
                                 65,
                                 128,
                                 '',
                                 NULL,
                                 FALSE); 
      }
    }

    // Display the user documentation of placeholders supported by
    // this module
    foreach ($settings->placeholders as $name => $description) {
      $items .= '<dt>'.$name.'</dt>';
      $items .= '<dd>'.$description.'</dd>';
    }
  
    // If the module supports bulk updates, offer the update action here
    if ($settings->bulkname) {
      $variable = 'pathauto_'.$module.'_bulkupdate';
      if (variable_get($variable, FALSE)) {
        variable_set($variable, FALSE);
        $function = $module.'_pathauto_bulkupdate';
        call_user_func($function);
      }
      $items .= form_checkbox($settings->bulkname, $variable, 
        1, FALSE, $settings->bulkdescr);
    }
    
    // Perform bulk updates of indexes for this module, if asked
    if ($do_index_bulkupdate) {
      $function = $module.'_pathauto_bulkupdate_indexes';
      if (is_callable($function)) {
        $indexcount += call_user_func($function);
      }
    }
    
    $output .= form_group($groupheader, $items, '');
  }
  
  if ($do_index_bulkupdate) {
    drupal_set_message(format_plural($indexcount,
      "Bulk update of index aliases completed, one alias generated.",
      "Bulk update of index aliases completed, %count aliases generated."));
  }
  
  // Keep track of which modules currently support pathauto
  variable_set('pathauto_modulelist', $modulelist);
  
  return $output;
}

// Make sure there isn't already an alias pointing to a different item
function _pathauto_alias_exists($alias, $src) {
  return db_result(db_query(
    "SELECT COUNT(dst) FROM {url_alias} WHERE dst = '%s' AND src != '%s'", 
    $alias, $src));
}

// Clean up a string value provided by a module, resulting in a
// string containing only alphanumerics and separators
function _pathauto_cleanstring($string, $separator) {
  // Drop apostrophes
  $output = str_replace("'", "", $string);

  // Convert accented characters to their ASCII counterparts...
  $output = strtr(utf8_decode($output),
       "\xA1\xAA\xBA\xBF".
       "\xC0\xC1\xC2\xC3\xC5\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF".
       "\xD0\xD1\xD2\xD3\xD4\xD5\xD8\xD9\xDA\xDB\xDD".
       "\xE0\xE1\xE2\xE3\xE5\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF".
       "\xF0\xF1\xF2\xF3\xF4\xF5\xF8\xF9\xFA\xFB\xFD\xFF",
       "!ao?AAAAACEEEEIIIIDNOOOOOUUUYaaaaaceeeeiiiidnooooouuuyy"); 
  // ...and ligatures too
  $output = utf8_encode(strtr($output, array("\xC4"=>"Ae", "\xC6"=>"AE", "\xD6"=>"Oe", 
    "\xDC"=>"Ue", "\xDE"=>"TH", "\xDF"=>"ss", "\xE4"=>"ae", "\xE6"=>"ae", 
    "\xF6"=>"oe", "\xFC"=>"ue", "\xFE"=>"th")));

  // Preserve alphanumerics and slashes, everything else becomes a separator
  $pattern = '/[^a-zA-Z0-9_\/\-]+/ ';
  $output = preg_replace($pattern, $separator, $output);

  // Trim any leading or trailing separators (note the need to
  // escape the separator if and only if it is not alphanumeric)
  if ($separator) {
    if (ctype_alnum($separator)) {
      $seppattern = $separator;
    } else {
      $seppattern = '\\'.$separator;
    }
    $output = preg_replace("/^$seppattern+|$seppattern+$/", "", $output);
  }
  return $output;
}

/**
 * Apply patterns to create an alias
 *
 * @param $module
 *   The name of your module (e.g., 'node')
 * @param $op
 *   Operation being performed on the content being aliased ('insert',
 *   'update', or 'bulkupdate')
 * @param $placeholders
 *   An array whose keys consist of the translated placeholders
 *   which appear in patterns (e.g., t('[title]')) and values are the 
 *   actual values to be substituted into the pattern (e.g., $node->title)
 * @param $src
 *   The "real" URI of the content to be aliased (e.g., "node/$node->nid")
 * @param $type
 *   For modules which provided patternitems in hook_autopath(),
 *   the relevant identifier for the specific item to be aliased (e.g.,
 *   $node->type)
 * @return
 *   The alias that was created
 */
function pathauto_create_alias($module, $op, $placeholders, $src, $type=NULL) {
  if (($op != 'bulkupdate') and variable_get('pathauto_verbose', FALSE)) {
    $verbose = TRUE;
  } else {
    $verbose = FALSE;
  }
  
  // Retrieve and apply the pattern for this content type
  $pattern = '';
  if ($type) {
    $pattern = strtolower(variable_get('pathauto_'.$module.'_'.$type.'_pattern', ''));
  } 
  if (!trim($pattern)) {
    $pattern = strtolower(variable_get('pathauto_'.$module.'_pattern', ''));
  }
  
  // No pattern? Do nothing (otherwise we may blow away existing aliases...)
  if (!trim($pattern)) {
    return '';
  }
  
  // Special handling when updating an item which is already aliased
  $pid = NULL;
  if ($op == 'update' or $op == 'bulkupdate') {
    $result = db_query("SELECT pid,dst FROM {url_alias} WHERE src='%s'", $src);
    if ($data = db_fetch_object($result)) {
      // The item is already aliased, check what to do...
      switch (variable_get('pathauto_update_action', 0)) {
        // Do nothing
        case 0:
          return '';
        // Add new alias in addition to old one
        case 1:
          $oldalias = $data->dst;
          break;
        // Replace old alias - remember the pid to update
        case 2:
          $pid = $data->pid;
          $oldalias = $data->dst;
          break;
        default:
          break;
      }
    }
  }
  
  $separator = variable_get('pathauto_separator', '_');

  // Clean all replacement strings
  foreach ($placeholders as $key => $value) {
    $placeholders[$key] = _pathauto_cleanstring($value, $separator);
  }

  // Replace the placeholders with the values provided by the module,
  // and lower-case the result
  $alias = str_replace(array_keys($placeholders), $placeholders, $pattern);
  $alias = strtolower($alias);
  
  // Two or more slashes should be collapsed into one
  $alias = preg_replace("/\/+/", "/", $alias);
  // Trim any leading or trailing slashes
  $alias = preg_replace("/^\/|\/+$/", "", $alias);

  // If the alias already exists, generate a new variant
  if (_pathauto_alias_exists($alias, $src)) {
    for ($i=0; _pathauto_alias_exists($alias.$separator.$i, $src); $i++) {
    }
    $alias = $alias.$separator.$i;
  }
  
  // If $pid is NULL, a new alias is created - otherwise, the existing
  // alias for the designated src is replaced
  _pathauto_set_alias($src, $alias, $pid, $verbose, $oldalias);

  // Also create a related feed alias if requested, and if supported
  // by the module
  if (variable_get('pathauto_applytofeed', FALSE)) { 
    $feedappend = variable_get('pathauto_'.$module.'_supportsfeeds', '');
    if ($feedappend != '') {
      // Handle replace case (get existing pid)
      _pathauto_set_alias("$src/$feedappend", "$alias/feed", NULL, $verbose);
    }
  }
  
  // Create any relevant index aliases if requested
  if (variable_get('pathauto_indexaliases', FALSE)) {
    pathauto_create_index_alias($alias, $module);
  }
  
  return $alias;
}

function _pathauto_set_alias($src, $dst, $pid = NULL, $verbose = FALSE, $oldalias = NULL) {
  // Skip replacing the current alias with an identical alias
  if ($oldalias != $dst) {
    path_set_alias($src, $dst, $pid);
    if ($verbose and user_access('create url aliases')) {
      if ($pid) {
        drupal_set_message("Created new alias <b>$dst</b> for <b>$src</b>, replacing <b>$oldalias</b>");
      } else {
        drupal_set_message("Created new alias <b>$dst</b> for <b>$src</b>");
      }
    }
  }
}

function pathauto_create_index_alias($alias, $module) {
  $count = 0;
  $components = explode('/', $alias);
  // Not interested in the trailing component
  array_pop($components);
  $alias = '';
  foreach ($components as $component) {
    if ($alias) {
      $alias .= '/'.$component;
    } else {
      $alias .= $component;
    }
    $alias_count = db_result(db_query("SELECT COUNT(dst) FROM {url_alias} WHERE dst = '%s'", $alias));
    if (!$alias_count) {
      $src = "pathauto/$module/$alias";
      _pathauto_set_alias($src, $alias);
      $count++;
    }
  }
  return $count;
}

function pathauto_menu($may_cache) {
  $items = array();
  $modulelist = variable_get('pathauto_modulelist', array());
  foreach ($modulelist as $module) {
    $items[] = array('path' => 'pathauto/'.$module,
      'title' => t('Pathauto'),
      'callback' => $module.'_pathauto_page', 
      'access' => 1,
      'type' => MENU_HIDE);
  }
  return $items;
}

/**
 * Returns the version of this release of the pathauto module.
 *
 * @return array An array with keys 'text' and 'build' containing the
 *         text version and build ID of this release, respectively.
 */
function _pathauto_version() {
  return array("text" => "2005-7-4", "build" => 3);
} // function _pathauto_version

/**
 * Makes updates to saved variables and the database structure.
 **/
function _pathauto_update() {
  $installed_version  = variable_get('pathauto_version', array('text'=> 'Unknown', 'build' => 1));
  $current_version =  _pathauto_version();

  if ( $installed_version['build'] < $current_version['build']) {  
    // Upgrading from original version - variable names were changed 
    if ( $installed_version['build'] <= 1 ) {
      // Remove obsolete bulkupdate variables
      variable_del('pathauto_bulkupdate');
      variable_del('pathauto_cat_bulkupdate');

      // The original global node and taxonomy patterns got renamed
      $old_pattern = variable_get('pathauto_pattern', 0);
      if ($old_pattern != 0) {
        variable_set('pathauto_node_pattern', $old_pattern);
        variable_del('pathauto_pattern');
      }
      $old_pattern = variable_get('pathauto_cat_pattern', 0);
      if ($old_pattern != 0) {
        variable_set('pathauto_taxonomy_pattern', $old_pattern);
        variable_del('pathauto_cat_pattern');
      }
      // And the form of the type-specific patterns was changed
      $query = 'SELECT name,value FROM {variable} '.
        "WHERE name LIKE '%_pathauto_pattern'";
      $result = db_query($query);
      $var = db_fetch_object($result);
      while ($var) {
        $type = substr($var->name, 0, strlen($var->name)-strlen('_pathauto_pattern'));
        $old_pattern = variable_get($var->name, '');
        $new_name = 'pathauto_node_'.$type.'_pattern';
        variable_set($new_name, $old_pattern);
        variable_del($var->name);
        $var = db_fetch_object($result);
      }
      $query = 'SELECT name,value FROM {variable} '.
        "WHERE name LIKE '%_pathauto_cat_pattern'";
      $result = db_query($query);
      $var = db_fetch_object($result);
      while ($var) {
        $type = substr($var->name, 0, strlen($var->name)-strlen('_pathauto_cat_pattern'));
        $old_pattern = variable_get($var->name, '');
        $new_name = 'pathauto_taxonomy_'.$type.'_pattern';
        variable_set($new_name, $old_pattern);
        variable_del($var->name);
        $var = db_fetch_object($result);
      }
    }
    if ( $installed_version['build'] <= 2 ) {
      // Change feed support variables from booleans to appended strings
      $query = 'SELECT name,value FROM {variable} '.
        "WHERE name LIKE 'pathauto_%_supportsfeeds'";
      $result = db_query($query);
      $var = db_fetch_object($result);
      while ($var) {
        $type = substr($var->name, 9, strlen($var->name)-23);
        $old_value = variable_get($var->name, FALSE);
        if ($old_value) {
          switch ($type) {
            case 'blog':
            case 'node':
              variable_set($var->name, 'feed');
              break;
            case 'taxonomy':
              variable_set($var->name, '0/feed');
              break;
          }
        } else {
          variable_set($var->name, '');
        }
        $var = db_fetch_object($result);
      }
      // Update previously-generated taxonomy aliases to remove the "/0"
      $query = "SELECT * FROM {url_alias} WHERE src LIKE 'taxonomy/term/%/0'";
      $result = db_query($query);
      $aliasrow = db_fetch_object($result);
      while ($aliasrow) {
        $src = substr($aliasrow->src, 0, -2);
        _pathauto_set_alias($src, $aliasrow->dst, $aliasrow->pid, FALSE);
        $aliasrow = db_fetch_object($result);
      }
    }
    if ($installed_version['build'] <= 3) {
      // Change taxonomy pattern variables to use IDs instead
      // of names
      $query = 'SELECT name,value FROM {variable} '.
        "WHERE name LIKE 'pathauto_taxonomy_%_pattern'";
      $result = db_query($query);
      $var = db_fetch_object($result);
      while ($var) {
        $vocabname = substr($var->name, 18, strlen($var->name)-26);
        $query = "SELECT vid FROM {vocabulary} WHERE name='$vocabname'";
        $vid = db_result(db_query($query));
        variable_set("pathauto_taxonomy_$vid_pattern", $var->value);
        variable_del($var->name);
        $var = db_fetch_object($result);
      }
    }

    // Set the current version
    variable_set('pathauto_version', $current_version);

    drupal_set_message('Upgraded pathauto from '.$installed_version['build'] .
      ' to '. $current_version['build']);
  } 
} // end function _pathauto_update 

?>